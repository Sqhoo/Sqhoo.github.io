<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud利用Eureka搭建注册中心]]></title>
    <url>%2F2019%2F01%2F18%2FSpringCloud%E5%88%A9%E7%94%A8Eureka%E6%90%AD%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[¶什么是SpringCloud Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 ¶创建服务注册中心 这里采用Eureka作为服务注册与发现的组件 创建一个springboot项目，勾选Eureka组件 编写配置文件（这里使用yml类型的配置文件） application.yml 1234567891011#设置服务器端口server: port: 8761#配置eureka注册相关配置eureka: client: register-with-eureka: false fetch-registry: false #配置注册中心url service-url: defaultzone: http://localhost:$&#123;server.port&#125;/eureka/ 编写启动类 在启动类上加上@EnableEurekaServer来标识这是注册中心 SpringcloudServerApplication.java 12345678@EnableEurekaServer@SpringBootApplicationpublic class SpringcloudServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringcloudServerApplication.class, args); &#125;&#125; 启动服务 访问http://localhost:8761能看到以下界面，但是还没有服务注册进来 ¶创建一个client服务 创建项目的步骤和之前的步骤一样，创建好项目之后，需要配置application.yml文件 123456789101112#设置服务的名称spring: application: name: service-client#设置服务器的端口server: port: 8762#设置服务注册中心地址eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 编写启动类 通过注解@EnableEurekaClient 表明自己是一个eurekaclient SpringcloudClientApplication.java 123456789101112131415161718package com.springcloudclient;@EnableEurekaClient@SpringBootApplication@RestControllerpublic class SpringcloudClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringcloudClientApplication.class, args); &#125; @Value("$&#123;server.port&#125;") String port; @RequestMapping("/client") public String client1(@RequestParam String name)&#123; return "hi "+name+" this is port:"+port; &#125;&#125; ¶启动工程 访问http://localhost:8761，可以看到服务已经被注册到注册中心 这时候可以访问http://localhost:8762/client?name=tom 页面显示为 ¶参考资料 https://blog.csdn.net/forezp/article/details/81040925 百度百科]]></content>
      <categories>
        <category>java框架区</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用SpringBoot搭建简单的MVC环境]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%88%A9%E7%94%A8SpringBoot%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84MVC%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[¶什么是springboot Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 ¶搭建MVC框架 在pom文件中导入依赖 说明： 1234567&lt;!-- 这一块是springboot核心依赖部分 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 依赖： 12345678910111213141516171819202122232425262728&lt;!-- 这里我们使用阿里巴巴的数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- springboot web项目相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatis 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 视图解析器的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql数据库连接依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置文件 这里我们采用yml文件来配置 1234567891011121314151617181920212223242526# 服务器配置server: # 配置服务器端口号 port: 8080 # 配置启动根路径 servlet: context-path: /hsq# spring的配置spring: # 配置数据源以及连接池 datasource: url: jdbc:mysql://localhost:3306/happyCake username: root password: root platform: mysql driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource# mybatis配置mybatis: # 配置实体类的包路径 type-aliases-package: com.springboot.entity # 配置驼峰命名规则 configuration: map-underscore-to-camel-case: true # 配置mapper.xml文件扫描 mapper-locations: classpath:mapper/*.xml **这里需要注意:**如果出现configuration与config-locations不能同时存在的错误，需要将config-locations换成mapper-locations 开始进行包的创建 我的项目的包结构如下 编写实体类 1234567891011package com.springboot.entity;public class User &#123; private String userId; private String username; private String password; private String userEmail; private String userTel; private String userTime;&#125;// 此处省略getter和setter方法 编写dao层 创建dao层接口UserDao 1234567package com.springboot.dao;// 注解Mapper作用是将此接口交给spring管理（IOC）@Mapperpublic interface UserDao &#123; List&lt;User&gt; getUser();&#125; 编写mapper.xml文件 123456&lt;mapper namespace="com.springboot.dao.UserDao"&gt; &lt;!-- id需要与UserDao的方法名相同 --&gt; &lt;select id="getUser" resultType="User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写service层 先创建好接口 123456789package com.springboot.service;import com.springboot.entity.User;import java.util.List;public interface UserService &#123; public List&lt;User&gt; getUser();&#125; 然后编写实现类 123456789101112131415161718package com.springboot.service.impl;// 将UserServiceImpl控制权交给spring（IOC）@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao;// idea编译器userDao报红为编译器bug，不用理会 @Autowired public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public List&lt;User&gt; getUser() &#123; return userDao.getUser(); &#125;&#125; 注意:@Autowired最好注解在构造函数上，因为当这个类生成时，先执行构造方法，如果构造方法已经用到userDao这个变量时，userDao还没有被注入，会出错，并且userDao一定是final类型，可写可不写。 123456789// 类似这种写法会报错public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; List&lt;User&gt; user = this.userDao.getUser(); &#125;&#125; 编写控制器 12345678910111213141516171819package com.springboot.control;// 此注解为@ResponseBody与@Controller的合体@RestController// 此控制器映射在/根目录/user下@RequestMapping("/user")public class UserControl &#123; private final UserService userService; @Autowired public UserControl(UserService userService) &#123; this.userService = userService; &#125; // 此接口映射在/根目录/user/getUser下 @RequestMapping("/getUser") public List&lt;User&gt; getUser()&#123; return userService.getUser(); &#125;&#125; 编写main函数 1234567891011package com.springboot;// 此注解为标示此类为springboot启动类@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 运行结果 访问http://localhost:8080/hsq/user/getUser]]></content>
      <categories>
        <category>java框架区</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程相关知识总结]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[¶什么是线程 线程是进程中的一个实体，是被系统独立调度和分派的基本单位 ¶线程和进程的区别 进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,是操作系统进行资源分配和调度的一个独立单位。 线程:是进程的一个实体,是 cpu 调度和分派的基本单位,是比进程更小的可以独立运行的基本单位。 特点:线程的划分尺度小于进程,这使多线程程序拥有高并发性,进程在运行时各自内存单元相互独立,线程之间内存共享,这使多线程编程可以拥有更好的性能和用户体验。 ¶创建线程的4种方法 继承Thread类 定义Thread类的子类，并重写run方法,run方法就是线程所要完成是任务 创建Thread类的实例 调用该线程的start方法以启动线程 ThreadMethod.java 123456public class ThreadMethod extends Thread&#123; @Override public void run() &#123; System.out.println("继承Thread方法"); &#125;&#125; Test.java 1234567@Testpublic void test() throws InterruptedException &#123; for (int i=0;i&lt;=5;i++)&#123; new ThreadMethod().start(); Thread.sleep(1000); &#125;&#125; 实现Runable接口 定义一个类实现Runable接口，重写run方法 创建该类的实例为Thread的Target参数，再创建一个Thread对象，将Target传入其构造函数中 调用该Thread对象的start方法以启动线程 RunableMethod.java 1234567public class RunableMethod implements Runnable&#123; @Override public void run() &#123; System.out.println("实现Runable方法"); &#125;&#125; Test.java 12345678910@Testpublic void test1() throws InterruptedException &#123; RunableMethod runableMethod=new RunableMethod(); Thread thread=null; for (int i=0;i&lt;=5;i++)&#123; thread=new Thread(runableMethod); thread.start(); Thread.sleep(1000); &#125;&#125; 实现callable接口 特点：callable实现call方法来作为执行体，有返回值 创建一个类实现Callable接口，重写call方法 在测试类中创建一个线程池，用来从中取得线程对象 创建这个类的对象，并同时创建一个FutureTask对象用来存放它 将这个FutureTask对象上传到线程池对象中 最后关闭线程池 CallableMethod.java 1234567public class CallableMethod implements Callable&#123; @Override public Integer call() throws Exception &#123; System.out.println("callable启动了"); return 0; &#125;&#125; Test.java 12345678910111213@Test public void name() throws InterruptedException &#123; ExecutorService executorService= Executors.newCachedThreadPool(); CallableMethod callableMethod=null; FutureTask&lt;Integer&gt; futureTask=null; for (int i = 0; i &lt; 5; i++) &#123; callableMethod=new CallableMethod(); futureTask=new FutureTask&lt;Integer&gt;(callableMethod); executorService.submit(futureTask); Thread.sleep(1000); &#125; executorService.shutdown(); &#125; 利用线程池创建线程 什么是线程池：线程池就是事先将多个对象放到一个容器中，当使用的时候就不用创建线程对象而是直接去线程池中拿线程即可。节省了开辟线程的时间，提高代码的执行效率。 常用线程池: 1. newSingleThreadExecutor:创建一个单线程的线程池,此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 2. newFixedThreadPool:创建固定大小的线程池,每次提交一个任务就创建一个线程,直到线程达到线程池的最大大小。 3. newCachedThreadPool:创建一个可缓存的线程池,此线程池不会对线程池大小做限制,线程池大小完全依赖于操作系统(或者说 JVM)能够创建的最大线程大小。 4. newScheduledThreadPool:创建一个大小无限的线程池,此线程池支持定时以及周期性执行任务的需求。 5. newSingleThreadExecutor:创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 Mythread.java 123456public class Mythread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+" 正在执行。。。。"); &#125;&#125; Test.java 123456789101112public class Test &#123; public static void main(String[] args) &#123; ExecutorService pool= Executors.newFixedThreadPool(3);//创建一个固定大小的线程池 Thread t1=new Mythread(); Thread t2=new Mythread(); Thread t3=new Mythread(); pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.shutdown(); &#125;&#125; 注意： 线程默认先执行当前类的线程(主线程)，然后再执行其他的线程。 ¶synchronized 和 volatile 关键字的作用 volatile 1）一旦一个成员变量或静态成员变量被volatile修饰后,就具备了两层意义 a.保证了不同线程对变量进行操作的可见性,也就是一个线程修改了值，这个值对其他线程也是可见的。 b.禁止进行指令重排序。 2）volatile本质是告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取。 3）只能使用在变量级别。 4）仅能实现变量的修改可见性，但是不能保证原子性。 5）不会造成线程阻塞。 6）volatile标记的变量不会被编译器优化。 synchronized 1）锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞 2）sychronized可以使用在变量、方法和类级别 3）sychronized可以保证变量修改的可见性和原子性 4）可能造成线程阻塞 5）sychronized标记的变量会被编译器优化 需求：循环打印A和B十次 TestA.java 123456789101112131415161718public class TestA implements Runnable &#123;@Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (TestAll.testAll) &#123; System.out.println("A"); count--; TestAll.testAll.notify(); try &#123; TestAll.testAll.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; TestB.java 123456789101112131415161718public class TestB implements Runnable &#123; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (TestAll.testAll) &#123; System.out.println("B"); count--; TestAll.testAll.notify(); try &#123; TestAll.testAll.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; TestAll.java 1234567public class TestAll &#123; public final static TestAll testAll=new TestAll(); public static void main(String[] args) &#123; new Thread(new TestA()).start(); new Thread(new TestB()).start(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tcp/ip协议]]></title>
    <url>%2F2018%2F07%2F26%2FTcp-ip%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[¶前言 我们先来了解一下http协议的请求流程： 建立连接：客户端与服务器建立TCP连接. 发送请求：打开一个连接后，客户端把请求信息发送到服务器的相应端口上，完成请求动作提交. 发送响应：服务器在处理完客户端请求之后，要向客户端发送响应消息。 关闭连接：客户端和服务器端都可以关闭套接字来结束TCP/IP对话 ¶TCP/IP 协议 Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 ¶重要的符号 Seq序号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 Ack序号：确认序号，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 标志位: URG：紧急指针有效 ACK：确认序号有效 PSH：接收方应该尽快将这个报文交给应用层 RST：重置连接 SYN：发起一个新连接 FIN：释放一个连接 注意: ACK表示的是确认序号有效的标志，Ack序号是一个序号，它的值是确认序号的值+1 ¶三次握手 第一次握手：客户端是发起一个新连接，将SYN置为1，随机产生一个序号j赋值给seq，将这两个数据以包的形式发送给客户端，客户端进入了SYN_SENT状态，等待服务端确认。 第二次握手：服务端收到数据包后，检查SYN为1，知道了客户端请求建立连接，将SYN和ACK都置为1，并将Ack序号置为客户端的确认序号seq+1（j+1），然后又随机产生一个新序号k赋值给seq,将这四个数据以包的形式传给客户端确认连接请求，服务端进入SYN_RCVD状态。 第三次握手：客户端收到数据包后，确认ACK是否为1以确认第一次握手中的seq是否有效，在检查Ack序号是否为j+1，满足则将ACK置为1，Ack序号置为服务端的确认序号seq+1（k+1）,将这些数据以包的形式发送给服务端，服务端如果检查到ACK为1，Ack序号为k+1，则建立成功，服务端和客户端进入ESTABLISHED状态，三次握手完成。 ¶四次挥手 第一次挥手：客户端发送一个FIN传达释放连接指令，随机产生一个序号j赋值给seq，进入FIN_WAIT_1状态 第二次挥手：服务端收到了客户端发来的FIN信号，同样需要发送ACK以确认seq有效，还需要置Ack为j+1并一起发送到服务端，并随机产生一个序号k赋值给seq。服务器进入CLOSE_WAIT状态 第三次挥手：服务器发送一个FIN，再发送一次ACK=1，用来关闭服务器到客户端之间的数据传送。服务端进入LAST_ACK状态 第四次挥手：客户端收到的ACK为1且Ack序号为j+1，则将ACK置为1表示确认序号有效，将Ack序号置为k+1，将数据以包的形式传给服务端，服务端收到检查到ACK为1表示确认序号有效，且Ack序号为k+1,则进入CLOSE状态，完成四次挥手。 注意: 为什么挥手为四次，握手为三次？ 因为在三次握手中，服务端收到了SYN=1信号，表示建立一个连接且可接收数据，服务器再将数据包传递给客户端确认已确认连接。但是在四次挥手中，服务器收到FIN=1时，表示发送了一个关闭连接的请求，但是并不代表客户端不能接受数据，所以先将一些数据包发给客户端，然后再发送FIN确认关闭请求。所以会与FIN分开发送。 ¶备注 TCP/IP 协议的概念来源于百度百科]]></content>
      <categories>
        <category>计算机网络区</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用jsp实现母版页]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%88%A9%E7%94%A8jsp%E5%AE%9E%E7%8E%B0%E6%AF%8D%E7%89%88%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[¶前言 如果制作若干使用相同外观框架且某个部分的内容不同的界面时，普通的html是不能实现这种功能的。jsp中的jsp:include标签可以实现母版页这个功能。 ¶使用方法 新建一个mater.jsp页面 代码如下： 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--其他代码从这里拼接--&gt; &lt;jsp:include page="&lt;%= request.getParameter(\"page\")%&gt;"/&gt;&lt;/body&gt;&lt;/html&gt; 新建一个son.jsp页面 代码如下： 1&lt;p&gt;hello,son.jsp&lt;/p&gt; 在浏览器访问 你的页面路径/master,jsp?page=son.jsp 结果如下 ¶说明 这种方法将master.jsp变成了母版页,只需要page的参数改变即可得到不同的界面共用相同的框架。page后面的参数值也可以是html页面。]]></content>
      <categories>
        <category>jsp区</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EL表达式]]></title>
    <url>%2F2018%2F07%2F09%2FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍一些常用的EL表达式 ¶首先先了解一下什么是EL表达式 EL表达式：EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 ¶针对EL表达式是否生效 请查下web.xml下的开头，如有以下内容，表示Servlet2.4 / JSP2.0 1234&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; 如果没有的话，说明是Servlet2.3 / JSP1.2,可在jsp页面直接加上这段话或者在开头加上&lt;%@ page isELIgnored=&quot;false&quot;&gt;或者，在web.xml中加入以下代码 123&lt;jsp-config&gt; &lt;el-ignored&gt;false&lt;/el-ignored&gt;&lt;/jsp-config&gt; ¶一些基本语法 使用变量名获取值 请看下面的例子： 1234&lt;%request.setAttribute("username","zhangsan"); %&gt;获取的值为：$&#123;username&#125; 运行结果: 使用对象名获取属性值 请看下面的例子： 首先定义一个实体类User,定义姓名、年龄、性别为这个类的属性，生成getter和setter方法 然后在jsp页面写上setter方法,然后用EL表达式取出数据。 12345678910&lt;%User user=new User();//实例化一个Useruser.setName="lisi";user.setAge=12;user.setSex="女";request.setAttribute("User",user);%&gt;姓名：$&#123;User.Name&#125;&lt;br&gt;年龄：$&#123;User.Age&#125;&lt;br&gt;性别：$&#123;User["Sex"]&#125;&lt;br&gt;//这也是一种方法 运行结果: 获取集合中的内容 例子如下： 12345678&lt;% List names=new ArrayList(); //定义一个list names.add("zhangsan"); names.add("lisi"); request.setAttribute("names",names);%&gt;姓名1:$&#123;names[0]&#125; &lt;br&gt;姓名2:$&#123;names[1]&#125; 运行结果: 获取Map中的内容 例子如下： 12345678&lt;% Map map=new HashMap();//定义一个hashmap map.put("one","zhangsan"); map.put("two","lisi"); request.setAttribute("map",map);%&gt;姓名1:$&#123;map["one"]&#125; &lt;br&gt;姓名2:$&#123;map["two"]&#125; 运行结果: EL表达式逻辑操作符 关系运算符 相等转换 == eq != ne &lt; lt &gt; gt &lt;= le &gt;= ge &amp;&amp; and ! not 注意： 在EL表达式中这两种都可以用例如${2 == 5}和${2 eq 5}返回的值都为false 备注： EL表达式概念来源百度百科 EL表达式生效问题来源博客园]]></content>
      <categories>
        <category>jsp区</category>
      </categories>
      <tags>
        <tag>EL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用session实现用户登录功能]]></title>
    <url>%2F2018%2F07%2F06%2F%E5%88%A9%E7%94%A8session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[¶什么是session? Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。 在这之前，我们现在创建一个登录界面 部分代码如下: Login.jsp 12345&lt;form method="post" id="form"&gt; username:&lt;input type="text" name="username"&gt;&lt;br&gt; password:&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 创建中间处理界面 这里用到了jsp中的RequestDispatcher对象: 它可以在对个界面实现请求数据的共享，所以这里的中间处理界面和welcome.jsp界面的内容必须进行共享，使得welcome.jsp中的数据可以跨界面使用 部分代码如下: doLogin.jsp 12345&lt;% String username=new String(request.getParameter("username").getBytes("ISO-8859-1"),"UTF-8");//处理中文乱码 session.setAttribute("username",username); request.getRequestDispatcher("welcome.jsp").forward(request,response);//与welocome.jsp实现session数据的共享%&gt; 创建欢迎界面 部分代码如下: Welcome.jsp 1234567891011welcome &#123;%String s=session.getAttribute("username");//如果取出的s为null，则没有经过登录界面进入该欢迎界面，非法访问，跳转到login进行登录。//因为如果s为null，则session中没有值，所以并没有进行登录来转到该欢迎界面，而是直接访问了该界面if(s==null)&#123; response.sendRedirect("login.jsp");&#125;else&#123; out.print(s);&#125;%&#125; 运行结果如下: Login.jsp: Welcome.jsp: 注意: 虽然显示的是/Welcome.jsp的内容，但是地址栏中的url为/doLogin.jsp,因为是Welcome.jsp的地位是被共享的，所以里面的内容都被doLogin.jsp共享了，所以显示的是doLogin.jsp界面。 备注: session的概念来源于百度百科]]></content>
      <categories>
        <category>jsp区</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2F2018%2F07%2F02%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 常用语法 ## 简介 > Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 ## 标题 1.用#来识别 例如： 12345# 一级标题## 二级标题### 三级标题#### 四级标题 ... 效果如下： 一级标题 ¶二级标题 ¶三级标题 ¶四级标题 2.用-或者=标记 例如： 1234一级标题-------二级标题======= 效果如下： 一级标题 ¶二级标题 ¶列表 1.有序列表 有序列表很好写，只需要写(数字|字母|其他能排序的字符).+空格+后面的内容即可。形如（1. 有序列表）。 下面给出一个示例： 1231. 第一句话2. 第二句话3. 第二句话 效果如下： 第一句话 第二句话 第三句话 2.无序列表 无序列表直接在前面用-、+和*作为标记： 123- 第一句话+ 第二句话* 第二句话 效果如下： 第一句话 第二句话 第三句话 ¶引用 这个用文字说明就很难说了，看下面的例子吧！！ 12345678910&gt; 这是一句引用 //在&gt;后面有一个空格&gt; 引用一小段代码 //在&gt;后面五个空格&gt; 以下是代码块：&gt; public static void main(String[] args)&#123; System.out.println("这是一个代码块！"); &#125;&gt;一级引用&gt;&gt;二级引用&gt;&gt;&gt;三级引用 效果如下： 这是一句引用 //在&gt;后面有一个空格 引用一小段代码 //在&gt;后面五个空格 以下是代码块： public static void main(String[] args){ System.out.println(&quot;这是一个代码块！&quot;); } 一级引用 二级引用 三级引用 ¶强调 两个*或者-代表加粗，一个*或者-代表斜体，~~ 代表删除,但是因为前端预览是js渲染的，后端输出php处理的，两者的markdown语法有差异~~来做删除线被认为是不规范的markdown语法，js渲染那边会去掉。建议采用html中&lt;del&gt;来删除。 1234**加粗** *斜体* ~~删除~~ &lt;del&gt;删除&lt;/del&gt; 效果如下： 加粗 斜体 删除 删除 ¶链接 1.图片链接格式：![]() ![填写图片文本(可忽略)](图片链接) 例如： ![](https://sqhoo.github.io/img/Cristiano.jpg)//行内式 ![][avatar]//参考式 //空一行 [avatar]:https://sqhoo.github.io/img/Cristiano.jpg/ 运行结果如下: 2.超链接格式：[]() ![文本](链接地址) 例如： [返回主页](https:/sqhoo.github.io)//行内式 [返回主页][url]//参考式 //空一行 [url]:https:/sqhoo.github.io &lt;https:/sqhoo.github.io&gt;//自动链接 运行结果如下： 返回主页 返回主页 https:/sqhoo.github.io ¶代码 1.行内代码 行内代码使用`文字`来实现 代码块用```+语言名称，然后末尾再加上```结束，中间写内容实现代码高亮 例如： 行内代码main(String[] args)的例子 代码块的例子 效果如下： 行内代码main(String[] args)的例子 123public static void main(String[] args)&#123; System.out.println("这是一个代码块！");&#125; ¶表格 表格对齐格式 居左: :---- 居中: :----:或---- 居右: ----: 例如： 1234|标题|标题|标题||:---|:---:|---:||left1|middle1|right1||left2|middle3|right3| 效果如下： 标题 标题 标题 left1 middle1 right1 left2 middle3 right3 ¶分割线 在一行中写三个*、-或_实现一条分割线，且本行不能有任何的除空格以外的东西。 例如： 1234567***---___* * * 效果如下： ¶换行 在句尾加两个空格并另起一行表示换行 例如： 123我要 换行 //没有加回车我要 换行 //加了两个空格 结果如下: 我要 换行 我要 换行 ¶脚注 用[^]来定义脚注 12转到脚注1[^1][^1]: 这里是脚注1 结果如下： 这是一个脚注的例子[1] **注意：**脚注不是markdown的基本语法，属于拓展语法，想实现这个功能，可以转到https://github.com/LouisBarranqueiro/hexo-footnotes下载拓展。我的这个网页没有这个拓展所以不支持，但是悬浮在上面可以看到左下角出来的内容含有这个注解。 ¶使用HTML标签说明 在markdown中可以使用任何的html标签，因为.md文件最终是转成html传上去的。 还是给出几个例子吧！ 123换行&lt;br&gt;&lt;br&gt;&lt;u&gt;下划线文本&lt;/u&gt;&lt;p style="color:green"&gt;字体变色&lt;/p&gt; 效果如下 换行 下划线文本 原谅色 这些就是markdown常用语法，一般引用，代码高亮，分割线、标题级别、链接、列表比较常用。 这是本人的第一个博客，将别人博客一些内容和自己的内容整合了一下，格式略糙，感谢支持QAQ！！！ 备注：Markdown简介来源百度百科 这里是脚注 ↩]]></content>
      <categories>
        <category>博客区</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>第一个博客</tag>
      </tags>
  </entry>
</search>
